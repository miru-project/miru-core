// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"reflect"

	log "github.com/miru-project/miru-core/pkg/logger"

	"github.com/miru-project/miru-core/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/miru-project/miru-core/ent/appsetting"
	"github.com/miru-project/miru-core/ent/extension"
	"github.com/miru-project/miru-core/ent/extensionreposetting"
	"github.com/miru-project/miru-core/ent/extensionsetting"
	"github.com/miru-project/miru-core/ent/favorite"
	"github.com/miru-project/miru-core/ent/favoritegroup"
	"github.com/miru-project/miru-core/ent/history"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AppSetting is the client for interacting with the AppSetting builders.
	AppSetting *AppSettingClient
	// Extension is the client for interacting with the Extension builders.
	Extension *ExtensionClient
	// ExtensionRepoSetting is the client for interacting with the ExtensionRepoSetting builders.
	ExtensionRepoSetting *ExtensionRepoSettingClient
	// ExtensionSetting is the client for interacting with the ExtensionSetting builders.
	ExtensionSetting *ExtensionSettingClient
	// Favorite is the client for interacting with the Favorite builders.
	Favorite *FavoriteClient
	// FavoriteGroup is the client for interacting with the FavoriteGroup builders.
	FavoriteGroup *FavoriteGroupClient
	// History is the client for interacting with the History builders.
	History *HistoryClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AppSetting = NewAppSettingClient(c.config)
	c.Extension = NewExtensionClient(c.config)
	c.ExtensionRepoSetting = NewExtensionRepoSettingClient(c.config)
	c.ExtensionSetting = NewExtensionSettingClient(c.config)
	c.Favorite = NewFavoriteClient(c.config)
	c.FavoriteGroup = NewFavoriteGroupClient(c.config)
	c.History = NewHistoryClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		AppSetting:           NewAppSettingClient(cfg),
		Extension:            NewExtensionClient(cfg),
		ExtensionRepoSetting: NewExtensionRepoSettingClient(cfg),
		ExtensionSetting:     NewExtensionSettingClient(cfg),
		Favorite:             NewFavoriteClient(cfg),
		FavoriteGroup:        NewFavoriteGroupClient(cfg),
		History:              NewHistoryClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		AppSetting:           NewAppSettingClient(cfg),
		Extension:            NewExtensionClient(cfg),
		ExtensionRepoSetting: NewExtensionRepoSettingClient(cfg),
		ExtensionSetting:     NewExtensionSettingClient(cfg),
		Favorite:             NewFavoriteClient(cfg),
		FavoriteGroup:        NewFavoriteGroupClient(cfg),
		History:              NewHistoryClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AppSetting.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AppSetting, c.Extension, c.ExtensionRepoSetting, c.ExtensionSetting,
		c.Favorite, c.FavoriteGroup, c.History,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AppSetting, c.Extension, c.ExtensionRepoSetting, c.ExtensionSetting,
		c.Favorite, c.FavoriteGroup, c.History,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AppSettingMutation:
		return c.AppSetting.mutate(ctx, m)
	case *ExtensionMutation:
		return c.Extension.mutate(ctx, m)
	case *ExtensionRepoSettingMutation:
		return c.ExtensionRepoSetting.mutate(ctx, m)
	case *ExtensionSettingMutation:
		return c.ExtensionSetting.mutate(ctx, m)
	case *FavoriteMutation:
		return c.Favorite.mutate(ctx, m)
	case *FavoriteGroupMutation:
		return c.FavoriteGroup.mutate(ctx, m)
	case *HistoryMutation:
		return c.History.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AppSettingClient is a client for the AppSetting schema.
type AppSettingClient struct {
	config
}

// NewAppSettingClient returns a client for the AppSetting from the given config.
func NewAppSettingClient(c config) *AppSettingClient {
	return &AppSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appsetting.Hooks(f(g(h())))`.
func (c *AppSettingClient) Use(hooks ...Hook) {
	c.hooks.AppSetting = append(c.hooks.AppSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appsetting.Intercept(f(g(h())))`.
func (c *AppSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppSetting = append(c.inters.AppSetting, interceptors...)
}

// Create returns a builder for creating a AppSetting entity.
func (c *AppSettingClient) Create() *AppSettingCreate {
	mutation := newAppSettingMutation(c.config, OpCreate)
	return &AppSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppSetting entities.
func (c *AppSettingClient) CreateBulk(builders ...*AppSettingCreate) *AppSettingCreateBulk {
	return &AppSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppSettingClient) MapCreateBulk(slice any, setFunc func(*AppSettingCreate, int)) *AppSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppSettingCreateBulk{err: fmt.Errorf("calling to AppSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppSetting.
func (c *AppSettingClient) Update() *AppSettingUpdate {
	mutation := newAppSettingMutation(c.config, OpUpdate)
	return &AppSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppSettingClient) UpdateOne(_m *AppSetting) *AppSettingUpdateOne {
	mutation := newAppSettingMutation(c.config, OpUpdateOne, withAppSetting(_m))
	return &AppSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppSettingClient) UpdateOneID(id int) *AppSettingUpdateOne {
	mutation := newAppSettingMutation(c.config, OpUpdateOne, withAppSettingID(id))
	return &AppSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppSetting.
func (c *AppSettingClient) Delete() *AppSettingDelete {
	mutation := newAppSettingMutation(c.config, OpDelete)
	return &AppSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppSettingClient) DeleteOne(_m *AppSetting) *AppSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppSettingClient) DeleteOneID(id int) *AppSettingDeleteOne {
	builder := c.Delete().Where(appsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppSettingDeleteOne{builder}
}

// Query returns a query builder for AppSetting.
func (c *AppSettingClient) Query() *AppSettingQuery {
	return &AppSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a AppSetting entity by its id.
func (c *AppSettingClient) Get(ctx context.Context, id int) (*AppSetting, error) {
	return c.Query().Where(appsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppSettingClient) GetX(ctx context.Context, id int) *AppSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppSettingClient) Hooks() []Hook {
	return c.hooks.AppSetting
}

// Interceptors returns the client interceptors.
func (c *AppSettingClient) Interceptors() []Interceptor {
	return c.inters.AppSetting
}

func (c *AppSettingClient) mutate(ctx context.Context, m *AppSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AppSetting mutation op: %q", m.Op())
	}
}

// ExtensionClient is a client for the Extension schema.
type ExtensionClient struct {
	config
}

// NewExtensionClient returns a client for the Extension from the given config.
func NewExtensionClient(c config) *ExtensionClient {
	return &ExtensionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extension.Hooks(f(g(h())))`.
func (c *ExtensionClient) Use(hooks ...Hook) {
	c.hooks.Extension = append(c.hooks.Extension, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extension.Intercept(f(g(h())))`.
func (c *ExtensionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Extension = append(c.inters.Extension, interceptors...)
}

// Create returns a builder for creating a Extension entity.
func (c *ExtensionClient) Create() *ExtensionCreate {
	mutation := newExtensionMutation(c.config, OpCreate)
	return &ExtensionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Extension entities.
func (c *ExtensionClient) CreateBulk(builders ...*ExtensionCreate) *ExtensionCreateBulk {
	return &ExtensionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtensionClient) MapCreateBulk(slice any, setFunc func(*ExtensionCreate, int)) *ExtensionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtensionCreateBulk{err: fmt.Errorf("calling to ExtensionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtensionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtensionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Extension.
func (c *ExtensionClient) Update() *ExtensionUpdate {
	mutation := newExtensionMutation(c.config, OpUpdate)
	return &ExtensionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtensionClient) UpdateOne(_m *Extension) *ExtensionUpdateOne {
	mutation := newExtensionMutation(c.config, OpUpdateOne, withExtension(_m))
	return &ExtensionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtensionClient) UpdateOneID(id int) *ExtensionUpdateOne {
	mutation := newExtensionMutation(c.config, OpUpdateOne, withExtensionID(id))
	return &ExtensionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Extension.
func (c *ExtensionClient) Delete() *ExtensionDelete {
	mutation := newExtensionMutation(c.config, OpDelete)
	return &ExtensionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtensionClient) DeleteOne(_m *Extension) *ExtensionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtensionClient) DeleteOneID(id int) *ExtensionDeleteOne {
	builder := c.Delete().Where(extension.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtensionDeleteOne{builder}
}

// Query returns a query builder for Extension.
func (c *ExtensionClient) Query() *ExtensionQuery {
	return &ExtensionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtension},
		inters: c.Interceptors(),
	}
}

// Get returns a Extension entity by its id.
func (c *ExtensionClient) Get(ctx context.Context, id int) (*Extension, error) {
	return c.Query().Where(extension.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtensionClient) GetX(ctx context.Context, id int) *Extension {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExtensionClient) Hooks() []Hook {
	return c.hooks.Extension
}

// Interceptors returns the client interceptors.
func (c *ExtensionClient) Interceptors() []Interceptor {
	return c.inters.Extension
}

func (c *ExtensionClient) mutate(ctx context.Context, m *ExtensionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtensionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtensionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtensionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtensionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Extension mutation op: %q", m.Op())
	}
}

// ExtensionRepoSettingClient is a client for the ExtensionRepoSetting schema.
type ExtensionRepoSettingClient struct {
	config
}

// NewExtensionRepoSettingClient returns a client for the ExtensionRepoSetting from the given config.
func NewExtensionRepoSettingClient(c config) *ExtensionRepoSettingClient {
	return &ExtensionRepoSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extensionreposetting.Hooks(f(g(h())))`.
func (c *ExtensionRepoSettingClient) Use(hooks ...Hook) {
	c.hooks.ExtensionRepoSetting = append(c.hooks.ExtensionRepoSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extensionreposetting.Intercept(f(g(h())))`.
func (c *ExtensionRepoSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExtensionRepoSetting = append(c.inters.ExtensionRepoSetting, interceptors...)
}

// Create returns a builder for creating a ExtensionRepoSetting entity.
func (c *ExtensionRepoSettingClient) Create() *ExtensionRepoSettingCreate {
	mutation := newExtensionRepoSettingMutation(c.config, OpCreate)
	return &ExtensionRepoSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExtensionRepoSetting entities.
func (c *ExtensionRepoSettingClient) CreateBulk(builders ...*ExtensionRepoSettingCreate) *ExtensionRepoSettingCreateBulk {
	return &ExtensionRepoSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtensionRepoSettingClient) MapCreateBulk(slice any, setFunc func(*ExtensionRepoSettingCreate, int)) *ExtensionRepoSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtensionRepoSettingCreateBulk{err: fmt.Errorf("calling to ExtensionRepoSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtensionRepoSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtensionRepoSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExtensionRepoSetting.
func (c *ExtensionRepoSettingClient) Update() *ExtensionRepoSettingUpdate {
	mutation := newExtensionRepoSettingMutation(c.config, OpUpdate)
	return &ExtensionRepoSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtensionRepoSettingClient) UpdateOne(_m *ExtensionRepoSetting) *ExtensionRepoSettingUpdateOne {
	mutation := newExtensionRepoSettingMutation(c.config, OpUpdateOne, withExtensionRepoSetting(_m))
	return &ExtensionRepoSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtensionRepoSettingClient) UpdateOneID(id int) *ExtensionRepoSettingUpdateOne {
	mutation := newExtensionRepoSettingMutation(c.config, OpUpdateOne, withExtensionRepoSettingID(id))
	return &ExtensionRepoSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExtensionRepoSetting.
func (c *ExtensionRepoSettingClient) Delete() *ExtensionRepoSettingDelete {
	mutation := newExtensionRepoSettingMutation(c.config, OpDelete)
	return &ExtensionRepoSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtensionRepoSettingClient) DeleteOne(_m *ExtensionRepoSetting) *ExtensionRepoSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtensionRepoSettingClient) DeleteOneID(id int) *ExtensionRepoSettingDeleteOne {
	builder := c.Delete().Where(extensionreposetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtensionRepoSettingDeleteOne{builder}
}

// Query returns a query builder for ExtensionRepoSetting.
func (c *ExtensionRepoSettingClient) Query() *ExtensionRepoSettingQuery {
	return &ExtensionRepoSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtensionRepoSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a ExtensionRepoSetting entity by its id.
func (c *ExtensionRepoSettingClient) Get(ctx context.Context, id int) (*ExtensionRepoSetting, error) {
	return c.Query().Where(extensionreposetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtensionRepoSettingClient) GetX(ctx context.Context, id int) *ExtensionRepoSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExtensionRepoSettingClient) Hooks() []Hook {
	hooks := c.hooks.ExtensionRepoSetting
	return append(hooks[:len(hooks):len(hooks)], extensionreposetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ExtensionRepoSettingClient) Interceptors() []Interceptor {
	return c.inters.ExtensionRepoSetting
}

func (c *ExtensionRepoSettingClient) mutate(ctx context.Context, m *ExtensionRepoSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtensionRepoSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtensionRepoSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtensionRepoSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtensionRepoSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExtensionRepoSetting mutation op: %q", m.Op())
	}
}

// ExtensionSettingClient is a client for the ExtensionSetting schema.
type ExtensionSettingClient struct {
	config
}

// NewExtensionSettingClient returns a client for the ExtensionSetting from the given config.
func NewExtensionSettingClient(c config) *ExtensionSettingClient {
	return &ExtensionSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `extensionsetting.Hooks(f(g(h())))`.
func (c *ExtensionSettingClient) Use(hooks ...Hook) {
	c.hooks.ExtensionSetting = append(c.hooks.ExtensionSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `extensionsetting.Intercept(f(g(h())))`.
func (c *ExtensionSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExtensionSetting = append(c.inters.ExtensionSetting, interceptors...)
}

// Create returns a builder for creating a ExtensionSetting entity.
func (c *ExtensionSettingClient) Create() *ExtensionSettingCreate {
	mutation := newExtensionSettingMutation(c.config, OpCreate)
	return &ExtensionSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExtensionSetting entities.
func (c *ExtensionSettingClient) CreateBulk(builders ...*ExtensionSettingCreate) *ExtensionSettingCreateBulk {
	return &ExtensionSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExtensionSettingClient) MapCreateBulk(slice any, setFunc func(*ExtensionSettingCreate, int)) *ExtensionSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExtensionSettingCreateBulk{err: fmt.Errorf("calling to ExtensionSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExtensionSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExtensionSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExtensionSetting.
func (c *ExtensionSettingClient) Update() *ExtensionSettingUpdate {
	mutation := newExtensionSettingMutation(c.config, OpUpdate)
	return &ExtensionSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExtensionSettingClient) UpdateOne(_m *ExtensionSetting) *ExtensionSettingUpdateOne {
	mutation := newExtensionSettingMutation(c.config, OpUpdateOne, withExtensionSetting(_m))
	return &ExtensionSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExtensionSettingClient) UpdateOneID(id int) *ExtensionSettingUpdateOne {
	mutation := newExtensionSettingMutation(c.config, OpUpdateOne, withExtensionSettingID(id))
	return &ExtensionSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExtensionSetting.
func (c *ExtensionSettingClient) Delete() *ExtensionSettingDelete {
	mutation := newExtensionSettingMutation(c.config, OpDelete)
	return &ExtensionSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExtensionSettingClient) DeleteOne(_m *ExtensionSetting) *ExtensionSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExtensionSettingClient) DeleteOneID(id int) *ExtensionSettingDeleteOne {
	builder := c.Delete().Where(extensionsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExtensionSettingDeleteOne{builder}
}

// Query returns a query builder for ExtensionSetting.
func (c *ExtensionSettingClient) Query() *ExtensionSettingQuery {
	return &ExtensionSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExtensionSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a ExtensionSetting entity by its id.
func (c *ExtensionSettingClient) Get(ctx context.Context, id int) (*ExtensionSetting, error) {
	return c.Query().Where(extensionsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExtensionSettingClient) GetX(ctx context.Context, id int) *ExtensionSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExtensionSettingClient) Hooks() []Hook {
	hooks := c.hooks.ExtensionSetting
	return append(hooks[:len(hooks):len(hooks)], extensionsetting.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ExtensionSettingClient) Interceptors() []Interceptor {
	return c.inters.ExtensionSetting
}

func (c *ExtensionSettingClient) mutate(ctx context.Context, m *ExtensionSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExtensionSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExtensionSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExtensionSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExtensionSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExtensionSetting mutation op: %q", m.Op())
	}
}

// FavoriteClient is a client for the Favorite schema.
type FavoriteClient struct {
	config
}

// NewFavoriteClient returns a client for the Favorite from the given config.
func NewFavoriteClient(c config) *FavoriteClient {
	return &FavoriteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `favorite.Hooks(f(g(h())))`.
func (c *FavoriteClient) Use(hooks ...Hook) {
	c.hooks.Favorite = append(c.hooks.Favorite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `favorite.Intercept(f(g(h())))`.
func (c *FavoriteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Favorite = append(c.inters.Favorite, interceptors...)
}

// Create returns a builder for creating a Favorite entity.
func (c *FavoriteClient) Create() *FavoriteCreate {
	mutation := newFavoriteMutation(c.config, OpCreate)
	return &FavoriteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Favorite entities.
func (c *FavoriteClient) CreateBulk(builders ...*FavoriteCreate) *FavoriteCreateBulk {
	return &FavoriteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FavoriteClient) MapCreateBulk(slice any, setFunc func(*FavoriteCreate, int)) *FavoriteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FavoriteCreateBulk{err: fmt.Errorf("calling to FavoriteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FavoriteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FavoriteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Favorite.
func (c *FavoriteClient) Update() *FavoriteUpdate {
	mutation := newFavoriteMutation(c.config, OpUpdate)
	return &FavoriteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FavoriteClient) UpdateOne(_m *Favorite) *FavoriteUpdateOne {
	mutation := newFavoriteMutation(c.config, OpUpdateOne, withFavorite(_m))
	return &FavoriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FavoriteClient) UpdateOneID(id int) *FavoriteUpdateOne {
	mutation := newFavoriteMutation(c.config, OpUpdateOne, withFavoriteID(id))
	return &FavoriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Favorite.
func (c *FavoriteClient) Delete() *FavoriteDelete {
	mutation := newFavoriteMutation(c.config, OpDelete)
	return &FavoriteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FavoriteClient) DeleteOne(_m *Favorite) *FavoriteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FavoriteClient) DeleteOneID(id int) *FavoriteDeleteOne {
	builder := c.Delete().Where(favorite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FavoriteDeleteOne{builder}
}

// Query returns a query builder for Favorite.
func (c *FavoriteClient) Query() *FavoriteQuery {
	return &FavoriteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFavorite},
		inters: c.Interceptors(),
	}
}

// Get returns a Favorite entity by its id.
func (c *FavoriteClient) Get(ctx context.Context, id int) (*Favorite, error) {
	return c.Query().Where(favorite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FavoriteClient) GetX(ctx context.Context, id int) *Favorite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a Favorite.
func (c *FavoriteClient) QueryGroup(_m *Favorite) *FavoriteGroupQuery {
	query := (&FavoriteGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(favorite.Table, favorite.FieldID, id),
			sqlgraph.To(favoritegroup.Table, favoritegroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, favorite.GroupTable, favorite.GroupPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FavoriteClient) Hooks() []Hook {
	return c.hooks.Favorite
}

// Interceptors returns the client interceptors.
func (c *FavoriteClient) Interceptors() []Interceptor {
	return c.inters.Favorite
}

func (c *FavoriteClient) mutate(ctx context.Context, m *FavoriteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FavoriteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FavoriteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FavoriteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FavoriteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Favorite mutation op: %q", m.Op())
	}
}

// FavoriteGroupClient is a client for the FavoriteGroup schema.
type FavoriteGroupClient struct {
	config
}

// NewFavoriteGroupClient returns a client for the FavoriteGroup from the given config.
func NewFavoriteGroupClient(c config) *FavoriteGroupClient {
	return &FavoriteGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `favoritegroup.Hooks(f(g(h())))`.
func (c *FavoriteGroupClient) Use(hooks ...Hook) {
	c.hooks.FavoriteGroup = append(c.hooks.FavoriteGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `favoritegroup.Intercept(f(g(h())))`.
func (c *FavoriteGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.FavoriteGroup = append(c.inters.FavoriteGroup, interceptors...)
}

// Create returns a builder for creating a FavoriteGroup entity.
func (c *FavoriteGroupClient) Create() *FavoriteGroupCreate {
	mutation := newFavoriteGroupMutation(c.config, OpCreate)
	return &FavoriteGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FavoriteGroup entities.
func (c *FavoriteGroupClient) CreateBulk(builders ...*FavoriteGroupCreate) *FavoriteGroupCreateBulk {
	return &FavoriteGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FavoriteGroupClient) MapCreateBulk(slice any, setFunc func(*FavoriteGroupCreate, int)) *FavoriteGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FavoriteGroupCreateBulk{err: fmt.Errorf("calling to FavoriteGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FavoriteGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FavoriteGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FavoriteGroup.
func (c *FavoriteGroupClient) Update() *FavoriteGroupUpdate {
	mutation := newFavoriteGroupMutation(c.config, OpUpdate)
	return &FavoriteGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FavoriteGroupClient) UpdateOne(_m *FavoriteGroup) *FavoriteGroupUpdateOne {
	mutation := newFavoriteGroupMutation(c.config, OpUpdateOne, withFavoriteGroup(_m))
	return &FavoriteGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FavoriteGroupClient) UpdateOneID(id int) *FavoriteGroupUpdateOne {
	mutation := newFavoriteGroupMutation(c.config, OpUpdateOne, withFavoriteGroupID(id))
	return &FavoriteGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FavoriteGroup.
func (c *FavoriteGroupClient) Delete() *FavoriteGroupDelete {
	mutation := newFavoriteGroupMutation(c.config, OpDelete)
	return &FavoriteGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FavoriteGroupClient) DeleteOne(_m *FavoriteGroup) *FavoriteGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FavoriteGroupClient) DeleteOneID(id int) *FavoriteGroupDeleteOne {
	builder := c.Delete().Where(favoritegroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FavoriteGroupDeleteOne{builder}
}

// Query returns a query builder for FavoriteGroup.
func (c *FavoriteGroupClient) Query() *FavoriteGroupQuery {
	return &FavoriteGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFavoriteGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a FavoriteGroup entity by its id.
func (c *FavoriteGroupClient) Get(ctx context.Context, id int) (*FavoriteGroup, error) {
	return c.Query().Where(favoritegroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FavoriteGroupClient) GetX(ctx context.Context, id int) *FavoriteGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFavorites queries the favorites edge of a FavoriteGroup.
func (c *FavoriteGroupClient) QueryFavorites(_m *FavoriteGroup) *FavoriteQuery {
	query := (&FavoriteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(favoritegroup.Table, favoritegroup.FieldID, id),
			sqlgraph.To(favorite.Table, favorite.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, favoritegroup.FavoritesTable, favoritegroup.FavoritesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FavoriteGroupClient) Hooks() []Hook {
	return c.hooks.FavoriteGroup
}

// Interceptors returns the client interceptors.
func (c *FavoriteGroupClient) Interceptors() []Interceptor {
	return c.inters.FavoriteGroup
}

func (c *FavoriteGroupClient) mutate(ctx context.Context, m *FavoriteGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FavoriteGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FavoriteGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FavoriteGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FavoriteGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FavoriteGroup mutation op: %q", m.Op())
	}
}

// HistoryClient is a client for the History schema.
type HistoryClient struct {
	config
}

// NewHistoryClient returns a client for the History from the given config.
func NewHistoryClient(c config) *HistoryClient {
	return &HistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `history.Hooks(f(g(h())))`.
func (c *HistoryClient) Use(hooks ...Hook) {
	c.hooks.History = append(c.hooks.History, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `history.Intercept(f(g(h())))`.
func (c *HistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.History = append(c.inters.History, interceptors...)
}

// Create returns a builder for creating a History entity.
func (c *HistoryClient) Create() *HistoryCreate {
	mutation := newHistoryMutation(c.config, OpCreate)
	return &HistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of History entities.
func (c *HistoryClient) CreateBulk(builders ...*HistoryCreate) *HistoryCreateBulk {
	return &HistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HistoryClient) MapCreateBulk(slice any, setFunc func(*HistoryCreate, int)) *HistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HistoryCreateBulk{err: fmt.Errorf("calling to HistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for History.
func (c *HistoryClient) Update() *HistoryUpdate {
	mutation := newHistoryMutation(c.config, OpUpdate)
	return &HistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HistoryClient) UpdateOne(_m *History) *HistoryUpdateOne {
	mutation := newHistoryMutation(c.config, OpUpdateOne, withHistory(_m))
	return &HistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HistoryClient) UpdateOneID(id int) *HistoryUpdateOne {
	mutation := newHistoryMutation(c.config, OpUpdateOne, withHistoryID(id))
	return &HistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for History.
func (c *HistoryClient) Delete() *HistoryDelete {
	mutation := newHistoryMutation(c.config, OpDelete)
	return &HistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HistoryClient) DeleteOne(_m *History) *HistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HistoryClient) DeleteOneID(id int) *HistoryDeleteOne {
	builder := c.Delete().Where(history.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HistoryDeleteOne{builder}
}

// Query returns a query builder for History.
func (c *HistoryClient) Query() *HistoryQuery {
	return &HistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a History entity by its id.
func (c *HistoryClient) Get(ctx context.Context, id int) (*History, error) {
	return c.Query().Where(history.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HistoryClient) GetX(ctx context.Context, id int) *History {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HistoryClient) Hooks() []Hook {
	return c.hooks.History
}

// Interceptors returns the client interceptors.
func (c *HistoryClient) Interceptors() []Interceptor {
	return c.inters.History
}

func (c *HistoryClient) mutate(ctx context.Context, m *HistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown History mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AppSetting, Extension, ExtensionRepoSetting, ExtensionSetting, Favorite,
		FavoriteGroup, History []ent.Hook
	}
	inters struct {
		AppSetting, Extension, ExtensionRepoSetting, ExtensionSetting, Favorite,
		FavoriteGroup, History []ent.Interceptor
	}
)
